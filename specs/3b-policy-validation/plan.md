# Implementation Plan: Policy Validation Enhancement

**Branch**: `3b-policy-validation` | **Date**: 2026-01-20 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/3b-policy-validation/spec.md`

## Summary

Epic 3B extends the existing PolicyEnforcer (Epic 3A) with:
1. **Semantic Validation** - Validate model references (`ref()`, `source()`) and detect circular dependencies
2. **Custom Rules** - Declarative validation rules in manifest.yaml (require_tags, require_meta, require_tests)
3. **Severity Overrides** - Pattern-based exceptions for legacy model migration
4. **Enhanced Context** - Downstream impact and historical tracking in violations
5. **Report Export** - SARIF 2.1.0 for GitHub Code Scanning, JSON, and HTML formats

Technical approach: Extend existing validator pattern, add new Pydantic schemas for custom rules/overrides, implement SARIF exporter, update CompiledArtifacts contract.

## Technical Context

**Language/Version**: Python 3.10+ (matches floe-core requirements)
**Primary Dependencies**: Pydantic v2, structlog, PyYAML, Jinja2 (HTML export)
**Storage**: N/A (enforcement is stateless; operates on dbt manifest.json)
**Testing**: pytest, K8s-native (Kind cluster for integration tests)
**Target Platform**: Linux (CI), macOS (development)
**Project Type**: Monorepo package (floe-core)
**Performance Goals**: <500ms for 500 models (SC-001)
**Constraints**: Must extend existing PolicyEnforcer without breaking API
**Scale/Scope**: Supports manifests with 1000+ models

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Principle I: Technology Ownership**
- [x] Code is placed in correct package (floe-core/enforcement/)
- [x] No SQL parsing/validation in Python (validates dbt manifest metadata only)
- [x] No orchestration logic outside floe-dagster (pure validation)

**Principle II: Plugin-First Architecture**
- [x] N/A - PolicyEnforcer is a CORE MODULE per ADR-0015 (not a plugin)
- [x] N/A - Validators are core, rules are configuration
- [x] N/A - No plugin metadata needed

**Principle III: Enforced vs Pluggable**
- [x] Enforced standards preserved (uses dbt manifest output, doesn't bypass)
- [x] Pluggable choices documented in manifest.yaml (custom_rules, policy_overrides)

**Principle IV: Contract-Driven Integration**
- [x] Cross-package data uses CompiledArtifacts (enforcement_result summary)
- [x] Pydantic v2 models for all schemas (CustomRule, PolicyOverride, etc.)
- [x] Contract changes follow versioning rules (v0.3.0 - additive only)

**Principle V: K8s-Native Testing**
- [x] Integration tests run in Kind cluster
- [x] No `pytest.skip()` usage
- [x] `@pytest.mark.requirement()` on all integration tests

**Principle VI: Security First**
- [x] Input validation via Pydantic (all config validated at load time)
- [x] N/A - No credentials involved in policy enforcement
- [x] No shell=True, no dynamic code execution (pattern matching uses fnmatch)

**Principle VII: Four-Layer Architecture**
- [x] Configuration flows downward only (manifest.yaml → PolicyEnforcer)
- [x] Layer ownership respected (Platform Team owns governance config)

**Principle VIII: Observability By Default**
- [x] OpenTelemetry traces emitted (existing spans in run_enforce_stage)
- [x] N/A - No data transformations (validation only)

## Project Structure

### Documentation (this feature)

```text
specs/3b-policy-validation/
├── plan.md              # This file
├── research.md          # Research decisions
├── data-model.md        # Entity definitions
├── quickstart.md        # Usage guide
├── contracts/           # JSON Schema contracts
│   ├── custom-rule.schema.json
│   ├── policy-override.schema.json
│   └── sarif-output.schema.json
├── checklists/
│   └── requirements.md  # Spec quality checklist
└── tasks.md             # Generated by /speckit.tasks
```

### Source Code (repository root)

```text
packages/floe-core/src/floe_core/
├── enforcement/
│   ├── __init__.py                    # Exports (update)
│   ├── policy_enforcer.py             # Main orchestrator (extend)
│   ├── result.py                      # Violation, EnforcementResult (extend)
│   ├── errors.py                      # PolicyEnforcementError (existing)
│   ├── validators/
│   │   ├── __init__.py
│   │   ├── naming.py                  # NamingValidator (existing)
│   │   ├── coverage.py                # CoverageValidator (existing)
│   │   ├── documentation.py           # DocumentationValidator (existing)
│   │   ├── semantic.py                # SemanticValidator (NEW)
│   │   └── custom_rules.py            # CustomRuleValidator (NEW)
│   └── exporters/
│       ├── __init__.py                # (NEW)
│       ├── json_exporter.py           # (NEW)
│       ├── sarif_exporter.py          # (NEW)
│       └── html_exporter.py           # (NEW)
└── schemas/
    ├── governance.py                  # NamingConfig, QualityGatesConfig (extend)
    ├── manifest.py                    # GovernanceConfig (extend)
    └── compiled_artifacts.py          # Add EnforcementResultSummary (extend)

packages/floe-core/tests/
├── unit/enforcement/
│   ├── test_policy_enforcer.py        # (existing, extend)
│   ├── test_semantic_validator.py     # (NEW)
│   ├── test_custom_rules_validator.py # (NEW)
│   ├── test_policy_overrides.py       # (NEW)
│   └── exporters/
│       ├── test_json_exporter.py      # (NEW)
│       ├── test_sarif_exporter.py     # (NEW)
│       └── test_html_exporter.py      # (NEW)
└── integration/enforcement/
    ├── test_pipeline_enforcement.py   # (existing, extend)
    └── test_enforcement_exports.py    # (NEW)

tests/contract/
└── test_enforcement_contract.py       # (NEW) EnforcementResultSummary contract
```

**Structure Decision**: Extends existing floe-core/enforcement/ module. New validators follow established pattern. Exporters get dedicated subpackage for organization.

## Implementation Phases

### Phase 1: Schema Extensions (FR-005, FR-011, FR-016)

1. Add `CustomRule` discriminated union to `governance.py`
2. Add `PolicyOverride` model to `governance.py`
3. Extend `GovernanceConfig` with `custom_rules` and `policy_overrides`
4. Extend `Violation` with context fields (downstream_impact, first_detected)
5. Add `EnforcementResultSummary` for CompiledArtifacts

### Phase 2: Semantic Validator (FR-001 - FR-004)

1. Implement `SemanticValidator` class
2. Add ref() resolution validation
3. Add source() resolution validation
4. Implement circular dependency detection (Kahn's algorithm)
5. Define FLOE-E301, E302, E303 error codes

### Phase 3: Custom Rules Validator (FR-006 - FR-010)

1. Implement `CustomRuleValidator` class
2. Add `require_tags_for_prefix` rule type
3. Add `require_meta_field` rule type
4. Add `require_tests_of_type` rule type
5. Define FLOE-E400, E401, E402 error codes

### Phase 4: Severity Overrides (FR-012 - FR-015)

1. Implement override pattern matching (fnmatch)
2. Add `downgrade` action (error → warning)
3. Add `exclude` action (skip validation)
4. Add expiration date checking
5. Add audit logging for applied overrides

### Phase 5: Report Exporters (FR-020 - FR-023)

1. Implement `export_json()` function
2. Implement `export_sarif()` function (SARIF 2.1.0)
3. Implement `export_html()` function (Jinja2 template)
4. Add `--output-format` CLI flag
5. Create output directory if needed

### Phase 6: Pipeline Integration (FR-024 - FR-026)

1. Update `run_enforce_stage()` to return summary
2. Add `enforcement_result` to CompiledArtifacts
3. Update `compile_pipeline()` to store summary
4. Ensure non-zero exit code on strict mode failure

## Complexity Tracking

> No constitution violations requiring justification.

| Item | Status | Notes |
|------|--------|-------|
| PolicyEnforcer as core module | Compliant | ADR-0015 decision - validators are core, rules are config |
| Contract version bump | Compliant | v0.2.0 → v0.3.0 (additive, backward compatible) |
| No plugin interface | Compliant | Intentional per ADR-0015 |

## Dependencies

### External
- `jinja2>=3.0` - HTML report templating (new dependency)
- `fnmatch` (stdlib) - Glob pattern matching

### Internal
- Epic 3A PolicyEnforcer - Must be complete and stable
- CompiledArtifacts v0.2.0 - Will become v0.3.0

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Performance with large manifests | <500ms goal may be missed | Lazy downstream_impact computation, profile with 1000 model manifests |
| SARIF schema compatibility | GitHub may not accept output | Validate against official schema in tests, use real upload in CI |
| Override pattern conflicts | Unexpected behavior | Process overrides in order, first match wins, log all matches |

## References

- [ADR-0015: Policy Enforcement as Core Module](../../../docs/architecture/adr/0015-policy-enforcement.md)
- [SARIF 2.1.0 Schema](https://github.com/oasis-tcs/sarif-spec/blob/main/sarif-2.1/schema/sarif-schema-2.1.0.json)
- [GitHub SARIF Support](https://docs.github.com/en/code-security/code-scanning/integrating-with-code-scanning/sarif-support-for-code-scanning)
- [research.md](research.md) - Detailed research decisions
- [data-model.md](data-model.md) - Entity definitions
