#!/usr/bin/env bash
# Architecture Drift Detector
# Checks for violations of layer boundaries and technology ownership
#
# Usage:
#   ./scripts/check-architecture-drift [file_path]
#   ./scripts/check-architecture-drift  # checks all changed files
#
# Exit codes:
#   0 - No drift detected
#   1 - Drift detected (warnings)
#   2 - Critical drift (blocking violations)

set -euo pipefail

# Colors
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m'

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

log_info() { echo -e "${BLUE}[arch-drift]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[arch-drift]${NC} WARNING: $1" >&2; }
log_error() { echo -e "${RED}[arch-drift]${NC} VIOLATION: $1" >&2; }
log_ok() { echo -e "${GREEN}[arch-drift]${NC} $1"; }

warnings=0
violations=0

# Technology Ownership Rules
# dbt owns SQL - Python must not parse/validate/transform SQL
check_dbt_ownership() {
    local file="$1"

    # Skip dbt package itself
    if [[ "$file" == *"floe-dbt"* ]]; then
        return 0
    fi

    # Check for SQL parsing in Python
    if grep -qE "(sqlparse|sql.*parse|parse.*sql|ast.*sql)" "$file" 2>/dev/null; then
        log_error "$file: SQL parsing detected - dbt owns SQL compilation"
        ((violations++))
    fi

    # Check for SQL validation
    if grep -qE "(validate.*sql|sql.*valid)" "$file" 2>/dev/null; then
        log_warn "$file: SQL validation detected - consider delegating to dbt"
        ((warnings++))
    fi
}

# Layer Boundary Rules
# Layer 4 (Data) must not modify Layer 2 (Configuration)
check_layer_boundaries() {
    local file="$1"

    # Data layer files (jobs, pipelines)
    if [[ "$file" == *"/jobs/"* || "$file" == *"/pipelines/"* ]]; then
        # Check for manifest.yaml modifications
        if grep -qE "(manifest\.yaml|write.*manifest|save.*manifest)" "$file" 2>/dev/null; then
            log_error "$file: Layer 4 (Data) modifying Layer 2 (Configuration) - FORBIDDEN"
            ((violations++))
        fi
    fi
}

# Contract Boundaries
# Packages must use CompiledArtifacts, not pass FloeSpec directly
check_contract_boundaries() {
    local file="$1"

    # Skip floe-core (it's allowed to use FloeSpec)
    if [[ "$file" == *"floe-core"* ]]; then
        return 0
    fi

    # Check for direct FloeSpec usage in other packages
    if grep -qE "from floe_core.* import.*FloeSpec|FloeSpec\(" "$file" 2>/dev/null; then
        # Allow type hints
        if ! grep -qE "FloeSpec\(" "$file" 2>/dev/null; then
            return 0
        fi
        log_warn "$file: Direct FloeSpec usage - use CompiledArtifacts for cross-package contracts"
        ((warnings++))
    fi
}

# Plugin Architecture Rules
check_plugin_rules() {
    local file="$1"

    # Plugin files
    if [[ "$file" == *"plugins/"* ]]; then
        # Check for hardcoded secrets
        if grep -qE "(password|secret|api_key|token)\s*=\s*['\"][^'\"]+['\"]" "$file" 2>/dev/null; then
            log_error "$file: Hardcoded secret in plugin - use SecretReference"
            ((violations++))
        fi

        # Check for missing entry point registration (in setup.py or pyproject.toml)
        if [[ "$file" == *"/plugin.py" ]]; then
            local package_dir
            package_dir=$(dirname "$file")
            if [[ ! -f "${package_dir}/pyproject.toml" ]]; then
                log_warn "$file: Plugin may be missing entry point registration"
                ((warnings++))
            fi
        fi
    fi
}

# Test Organization Rules
check_test_organization() {
    local file="$1"

    # Only check test files
    if [[ "$file" != *"/tests/"* && "$file" != *"/test_"* ]]; then
        return 0
    fi

    # Root-level tests should be cross-package
    if [[ "$file" == "${PROJECT_ROOT}/tests/"* ]]; then
        # Check if it imports from multiple packages
        local package_imports
        package_imports=$(grep -E "from (floe_core|floe_dagster|floe_dbt|floe_polaris)" "$file" 2>/dev/null | wc -l | tr -d ' ')
        package_imports=${package_imports:-0}

        if [[ "$package_imports" -lt 2 ]]; then
            log_warn "$file: Root-level test imports from <2 packages - should be in package tests/"
            ((warnings++))
        fi
    fi

    # Check for time.sleep in tests
    if grep -qE "time\.sleep\(" "$file" 2>/dev/null; then
        log_warn "$file: time.sleep() in test - use polling utilities instead"
        ((warnings++))
    fi

    # Check for pytest.skip
    if grep -qE "@pytest\.mark\.skip|pytest\.skip\(" "$file" 2>/dev/null; then
        log_error "$file: pytest.skip detected - tests must FAIL not skip"
        ((violations++))
    fi
}

check_file() {
    local file="$1"

    # Only check Python files
    if [[ ! "$file" == *.py ]]; then
        return 0
    fi

    # Skip non-existent files (deleted)
    if [[ ! -f "$file" ]]; then
        return 0
    fi

    log_info "Checking $file..."

    check_dbt_ownership "$file"
    check_layer_boundaries "$file"
    check_contract_boundaries "$file"
    check_plugin_rules "$file"
    check_test_organization "$file"
}

validate_file_path() {
    # Prevent path traversal - ensure file is within PROJECT_ROOT
    local file="$1"
    local resolved_path

    # Resolve to absolute path and check it's within project
    resolved_path=$(realpath -m "${PROJECT_ROOT}/${file}" 2>/dev/null) || return 1

    # Ensure path starts with PROJECT_ROOT (no traversal)
    if [[ "$resolved_path" != "${PROJECT_ROOT}"/* ]]; then
        log_warn "Path traversal attempt blocked: $file"
        return 1
    fi

    # Ensure file exists
    if [[ ! -f "$resolved_path" ]]; then
        return 1
    fi

    echo "$resolved_path"
}

main() {
    local target="${1:-}"

    if [[ -n "$target" ]]; then
        # Check specific file
        check_file "$target"
    else
        # Check all changed files
        log_info "Checking all changed Python files..."

        # Validate git refs exist before using them
        local base_ref="main"
        local head_ref="HEAD"

        if ! git rev-parse --verify "$base_ref" >/dev/null 2>&1; then
            base_ref="HEAD~10"
            if ! git rev-parse --verify "$base_ref" >/dev/null 2>&1; then
                log_info "No valid base ref found, skipping check"
                exit 0
            fi
        fi

        # Get changed files using validated refs with -- separator
        local changed_files
        changed_files=$(git diff --name-only "${base_ref}...${head_ref}" -- "*.py" 2>/dev/null || true)

        if [[ -z "$changed_files" ]]; then
            log_info "No changed files to check"
            exit 0
        fi

        while IFS= read -r file; do
            # Validate and resolve path (prevents traversal)
            local safe_path
            safe_path=$(validate_file_path "$file") || continue

            if [[ "$safe_path" == *.py ]]; then
                check_file "$safe_path"
            fi
        done <<< "$changed_files"
    fi

    # Summary
    echo ""
    if [[ $violations -gt 0 ]]; then
        log_error "========================================="
        log_error "ARCHITECTURE DRIFT DETECTED"
        log_error "Violations: $violations, Warnings: $warnings"
        log_error "========================================="
        exit 2
    elif [[ $warnings -gt 0 ]]; then
        log_warn "========================================="
        log_warn "ARCHITECTURE DRIFT WARNINGS"
        log_warn "Warnings: $warnings"
        log_warn "========================================="
        exit 1
    else
        log_ok "========================================="
        log_ok "NO ARCHITECTURE DRIFT DETECTED"
        log_ok "========================================="
        exit 0
    fi
}

main "$@"
